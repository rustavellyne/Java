package dz_5;


//Написать алгоритм бинарного поиска:
//int binarySearch(int [] data, int element); <- Ищет элемент element в data,
//возвращает индекс искомого элемента, или в случае отсутствия: -1. 
//Массив data заходит уже отсортированным.

public class task1 {
	
	
	int binarySearch(int [] data, int element) {
		System.out.println("ищем число: "+ element);
		int result = -1, first=0, midle, last=data.length; //инициализация первого, средины и последнего значений
		if (data != null) {   // проверка на пустой масив
			while(first < last) {   //пока первый елемнт меньшеге последнего делать
				midle = (first+last)/2;  //середине присваиваем первый и последний деленный на 2(последний выходит на еденицу больше так как .length это следуююший после последнего, но при округлениии середина получается верной)
				if(element == data[midle]) { //проверка равен ли искомый елемент значению с индексом середины и если да то
					
					while(midle!=0 && data[midle]==data[midle-1]) {// цикл на проверку одинаковых значений в масиве если таких несколько то вывести самый первый из них,
						result=midle;
						midle--;
						//if(midle==0)break;
					}//while равгых значений
					
						result = midle; //если же одинкавох значений нету то просто вывести
						break;// прервать цикл
				} else {                         // или если елемент меньше серединного
					if (element < data[midle]) { // так как знак меньше не включает значение midle(которое мы уже проверили)
						last=midle; //то ьеперь середина становиться последним елементом
					} else { //а если вдруг оказалось что елемент искомый не меньше середины 
						first=midle+1;// то первым значением стоовится следующий елемент середины
					}//else
				}//if 2
			}//while
		}//if null
		return result;
	}// metod binary search
}//class

